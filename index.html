<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Vie dedicate a persone da Overpass + Wikidata</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" integrity="sha256-XzD3RpaHPv7lzX9qt+2n1j5cWj48O24KsgaGYpKN8x8=" crossorigin="">
  <style>
    :root {
      --bg: #f4f4f6;
      --card: #ffffff;
      --text: #1f2933;
      --muted: #6b7280;
      --accent: #1459ff;
      --accent-2: #f97316;
      --border: #e5e7eb;
      --green: #22c55e;
      --pink: #d81b60;
      --violet: #7c3aed;
      --gray: #94a3b8;
    }
    * { box-sizing: border-box; }
    body {
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: radial-gradient(circle at 10% 20%, #eef2ff 0, #eef2ff 18%, transparent 22%), radial-gradient(circle at 80% 10%, #fff7ed 0, #fff7ed 18%, transparent 24%), var(--bg);
      color: var(--text);
    }
    h1 {
      font-size: 1.5rem;
      margin: 0 0 0.2rem 0;
      letter-spacing: -0.01em;
    }
    h2 {
      margin: 0 0 0.5rem 0;
      font-size: 1.1rem;
      letter-spacing: -0.01em;
    }
    p.small { margin: 0; color: var(--muted); font-size: 0.95rem; }
    .card {
      background: var(--card);
      padding: 1rem;
      border-radius: 0.8rem;
      box-shadow: 0 10px 30px rgba(17, 24, 39, 0.08);
      margin-bottom: 1rem;
      border: 1px solid #ecedf1;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.2rem 0.65rem;
      background: #eef2ff;
      color: #1d4ed8;
      border-radius: 999px;
      font-size: 0.9rem;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
      margin: 0.5rem 0 0 0;
    }
    button {
      padding: 0.55rem 0.95rem;
      border-radius: 0.45rem;
      border: 1px solid var(--border);
      background: #fff;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      color: #111827;
      transition: all 0.15s ease;
    }
    button.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }
    button.secondary {
      background: #fff;
      color: #111827;
    }
    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 6px 16px rgba(0,0,0,0.08); }
    button:disabled { opacity: 0.6; cursor: default; box-shadow: none; transform: none; }
    #map { height: 420px; border-radius: 0.7rem; overflow: hidden; border: 1px solid var(--border); }
    textarea {
      width: 100%;
      min-height: 120px;
      font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.9rem;
      padding: 0.7rem;
      border-radius: 0.6rem;
      border: 1px solid var(--border);
      background: #f9fafb;
      resize: vertical;
    }
    #status { color: var(--muted); font-size: 0.95rem; }
    #summary { margin-bottom: 0.4rem; color: var(--muted); }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.92rem;
      margin-top: 0.3rem;
    }
    th, td {
      padding: 0.5rem;
      border: 1px solid #e5e7eb;
      vertical-align: top;
    }
    thead { background: #f3f4f6; }
    .muted { color: var(--muted); }
    .gender-title {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 700;
      margin-top: 0.6rem;
    }
    .legend {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }
    .dot {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      display: inline-block;
      border: 1px solid #11182710;
    }
    a { color: #0f4de6; text-decoration: none; }
    a:hover { text-decoration: underline; }
    @media (max-width: 720px) {
      body { padding: 1rem; }
      #map { height: 320px; }
    }
  </style>
</head>
<body>
  <header style="margin-bottom: 1rem;">
    <h1>Vie dedicate a persone (Overpass + Wikidata)</h1>
    <p class="small">Disegna un rettangolo o un poligono sulla mappa, lancia la ricerca, e otterrai le vie con etimologia Wikidata per persone, suddivise per genere.</p>
  </header>

  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:0.5rem;flex-wrap:wrap;">
      <div class="pill">1) Disegna area · 2) Esegui Overpass · 3) Analizza Wikidata</div>
      <div class="toolbar">
        <button id="clearSelection" class="secondary">Cancella selezione</button>
        <button id="runBtn" class="primary">Cerca vie dedicate</button>
      </div>
    </div>
    <div id="map" style="margin-top:0.75rem;"></div>
    <div style="margin-top:0.75rem;">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:0.5rem;flex-wrap:wrap;">
        <strong>Query Overpass generata</strong>
        <span id="status"></span>
      </div>
      <textarea id="overpassQuery" readonly placeholder="Disegna un'area per generare la query"></textarea>
    </div>
  </div>

  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:0.5rem;">
      <h2 style="margin:0;">Risultati (persone)</h2>
      <div class="legend">
        <span class="dot" style="background:#2b7bff;"></span><span class="muted">Maschile</span>
        <span class="dot" style="background:#d81b60;"></span><span class="muted">Femminile</span>
        <span class="dot" style="background:#8c6bb1;"></span><span class="muted">Altro/Non binario</span>
        <span class="dot" style="background:#6c757d;"></span><span class="muted">Sconosciuto</span>
      </div>
    </div>
    <div id="summary" class="muted">Nessuna ricerca eseguita.</div>
    <div id="results">Nessun risultato ancora.</div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js" integrity="sha256-siofc4Uwjlra3YWkwthOn8Uj69cNN4aMug/iOHNiRgs=" crossorigin=""></script>
  <script>
    const overpassUrl = "https://overpass-api.de/api/interpreter";
    const wikidataSparql = "https://query.wikidata.org/sparql";

    function parseHashView() {
      const hash = window.location.hash.replace("#", "");
      if (!hash) return null;
      const parts = hash.split(",");
      if (parts.length !== 3) return null;
      const [lat, lng, zoom] = parts.map(Number);
      if ([lat, lng, zoom].some(n => Number.isNaN(n))) return null;
      return { lat, lng, zoom };
    }

    function updateHashFromMap(map) {
      const c = map.getCenter();
      const zoom = map.getZoom();
      const lat = c.lat.toFixed(5);
      const lng = c.lng.toFixed(5);
      window.location.hash = `${lat},${lng},${zoom}`;
    }

    const initialView = parseHashView() || { lat: 41.9028, lng: 12.4964, zoom: 12 };
    const map = L.map("map", { preferCanvas: true }).setView([initialView.lat, initialView.lng], initialView.zoom);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a>'
    }).addTo(map);

    const drawnItems = new L.FeatureGroup();
    let selectionGeoJSON = null;
    let streetsLayer = null;

    map.addLayer(drawnItems);
    map.addControl(new L.Control.Draw({
      draw: {
        polygon: { allowIntersection: false, showArea: true },
        rectangle: true,
        polyline: false,
        circle: false,
        circlemarker: false,
        marker: false
      },
      edit: { featureGroup: drawnItems, edit: false, remove: false }
    }));

    map.on(L.Draw.Event.CREATED, (e) => {
      drawnItems.clearLayers();
      drawnItems.addLayer(e.layer);
      selectionGeoJSON = e.layer.toGeoJSON();
      map.fitBounds(e.layer.getBounds().pad(0.1));
      updateQueryPreview();
    });

    map.on("moveend", () => updateHashFromMap(map));

    document.getElementById("clearSelection").addEventListener("click", () => {
      drawnItems.clearLayers();
      selectionGeoJSON = null;
      document.getElementById("overpassQuery").value = "";
      setStatus("Selezione rimossa.");
    });

    document.getElementById("runBtn").addEventListener("click", runSearch);

    function setStatus(text) {
      document.getElementById("status").textContent = text || "";
    }

    function geometryToOverpassArea(geojson) {
      if (!geojson || !geojson.geometry) throw new Error("Disegna un'area prima di eseguire la query.");
      const geom = geojson.geometry;
      if (geom.type !== "Polygon") throw new Error("Usa un poligono o un rettangolo.");
      const ring = geom.coordinates[0];
      const pairs = ring.map(([lng, lat]) => `${lat} ${lng}`).join(" ");
      return `(poly:"${pairs}")`;
    }

    function buildOverpassQuery() {
      const areaFilter = geometryToOverpassArea(selectionGeoJSON);
      return `// Vie con e senza etimologia Wikidata nell'area disegnata
[out:json][timeout:25];
(
  way["highway"]["name"]${areaFilter};
  relation["highway"]["name"]${areaFilter};
);
out body geom;`;
    }

    function updateQueryPreview() {
      const textarea = document.getElementById("overpassQuery");
      if (!selectionGeoJSON) {
        textarea.value = "";
        return;
      }
      textarea.value = buildOverpassQuery();
    }

    async function fetchOverpass(query) {
      const params = new URLSearchParams();
      params.set("data", query);
      const res = await fetch(overpassUrl, { method: "POST", body: params });
      if (!res.ok) throw new Error("Errore Overpass: " + res.status + " " + res.statusText);
      return res.json();
    }

    function getQidsFromTags(tags) {
      if (!tags) return [];
      const raw = tags["name:etymology:wikidata"] || tags["etymology:wikidata"];
      if (!raw) return [];
      return raw.split(";").map(q => q.trim()).filter(Boolean);
    }

    function formatYear(dateString) {
      if (!dateString) return null;
      const yearMatch = dateString.match(/(\d{4})/);
      return yearMatch ? yearMatch[1] : null;
    }

    function formatDateRange(birth, death) {
      const b = formatYear(birth);
      const d = formatYear(death);
      if (!b && !d) return "";
      return `${b || "?"} – ${d || "?"}`;
    }

    function categorizeGender(genderId) {
      if (!genderId) return "unknown";
      if (genderId === "Q6581097") return "male";
      if (genderId === "Q6581072") return "female";
      return "other";
    }

    function genderColor(cat) {
      return {
        male: "#2b7bff",
        female: "#d81b60",
        other: "#8c6bb1",
        unknown: "#6c757d"
      }[cat] || "#6c757d";
    }

    async function fetchWikidataBatch(qids) {
      const chunkSize = 40;
      const infoMap = new Map();

      for (let i = 0; i < qids.length; i += chunkSize) {
        const slice = qids.slice(i, i + chunkSize);
        const values = slice.map(q => `wd:${q}`).join(" ");
        const query = `
SELECT ?item ?itemLabel ?gender ?genderLabel ?birth ?death WHERE {
  VALUES ?item { ${values} }
  ?item wdt:P31/wdt:P279* wd:Q5.  # considera solo umani
  OPTIONAL { ?item wdt:P21 ?gender. }
  OPTIONAL { ?item wdt:P569 ?birth. }
  OPTIONAL { ?item wdt:P570 ?death. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language "it,en,mul". }
}`;
        const url = wikidataSparql + "?format=json&query=" + encodeURIComponent(query);
        const res = await fetch(url, { headers: { "Accept": "application/sparql-results+json", "User-Agent": "WikidataRoadsDemo/1.0" } });
        if (!res.ok) throw new Error("Errore Wikidata: " + res.status + " " + res.statusText);
        const json = await res.json();
        const rows = json.results.bindings || [];
        rows.forEach(b => {
          const item = b.item.value.split("/").pop();
          infoMap.set(item, {
            label: b.itemLabel ? b.itemLabel.value : item,
            genderId: b.gender ? b.gender.value.split("/").pop() : null,
            genderLabel: b.genderLabel ? b.genderLabel.value : null,
            birth: b.birth ? b.birth.value : null,
            death: b.death ? b.death.value : null
          });
        });
      }
      return infoMap;
    }

    function asFeature(el) {
      const tags = el.tags || {};
      if (el.type === "node" && el.lat != null && el.lon != null) {
        return {
          type: "Feature",
          geometry: { type: "Point", coordinates: [el.lon, el.lat] },
          properties: { id: `${el.type}/${el.id}`, tags }
        };
      }
      const geom = el.geometry;
      if (!geom || !geom.length) return null;
      const coords = geom.map(p => [p.lon, p.lat]);
      let geometry;
      if (coords.length >= 4 && coords[0][0] === coords[coords.length - 1][0] && coords[0][1] === coords[coords.length - 1][1]) {
        geometry = { type: "Polygon", coordinates: [coords] };
      } else {
        geometry = { type: "LineString", coordinates: coords };
      }
      return {
        type: "Feature",
        geometry,
        properties: { id: `${el.type}/${el.id}`, tags }
      };
    }

    function extractFeatures(osmJson) {
      const elements = osmJson.elements || [];
      const feats = elements.map(asFeature).filter(Boolean);
      const withNames = feats.filter(f => {
        const tags = f.properties && (f.properties.tags || f.properties);
        return tags && tags.name && getQidsFromTags(tags).length > 0;
      });
      return withNames;
    }

    function dedupeRows(rows) {
      const seen = new Set();
      return rows.filter(r => {
        const key = `${r.streetName}__${r.qid}`;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
    }

    function renderResults(rows) {
      const container = document.getElementById("results");
      if (!rows.length) {
        container.innerHTML = '<div class="muted">Nessun risultato per persone nell\'area selezionata.</div>';
        return;
      }
      const grouped = { male: [], female: [], other: [], unknown: [] };
      rows.forEach(r => grouped[r.genderCategory].push(r));

      const makeTable = (list) => {
        if (!list.length) return '<div class="muted">Nessun elemento.</div>';
        let html = '<table><thead><tr><th>Via</th><th>Persona (Wikidata)</th><th>Anno nasc./morte</th><th>QID</th></tr></thead><tbody>';
        list.forEach(r => {
          html += `<tr>
            <td>${r.streetName}</td>
            <td><a href="${r.wikidataUrl}" target="_blank" rel="noopener noreferrer">${r.personLabel}</a></td>
            <td>${r.dates || ""}</td>
            <td>${r.qid}</td>
          </tr>`;
        });
        html += "</tbody></table>";
        return html;
      };

      const sections = [
        { key: "female", label: "Femminile", color: genderColor("female") },
        { key: "male", label: "Maschile", color: genderColor("male") },
        { key: "other", label: "Altro / non binario", color: genderColor("other") },
        { key: "unknown", label: "Genere sconosciuto", color: genderColor("unknown") }
      ];

      container.innerHTML = sections.map(s => {
        return `<div style="margin-bottom:0.8rem;">
          <div class="gender-title"><span class="dot" style="background:${s.color};"></span>${s.label} (${grouped[s.key].length})</div>
          ${makeTable(grouped[s.key])}
        </div>`;
      }).join("");
    }

    function renderSummary(rows, qidCount, elementCount, distinctStreetsWithWikidata, distinctStreetsWithoutWikidata) {
      const summary = document.getElementById("summary");
      if (!rows.length) {
        summary.textContent = "Nessuna via dedicata a persone trovata.";
        return;
      }
      summary.textContent = `Elementi Overpass: ${elementCount} · QID unici: ${qidCount} · Vie dedicate a persone: ${rows.length} · Vie distinte con Wikidata: ${distinctStreetsWithWikidata} · Vie distinte senza Wikidata: ${distinctStreetsWithoutWikidata}`;
    }

    function renderMap(features, qidInfo) {
      if (streetsLayer) {
        map.removeLayer(streetsLayer);
      }
      streetsLayer = L.geoJSON(features, {
        style: (feat) => {
          const tags = feat.properties && (feat.properties.tags || feat.properties);
          const qids = getQidsFromTags(tags);
          const gender = qids.map(q => categorizeGender((qidInfo.get(q) || {}).genderId)).find(Boolean) || "unknown";
          return { color: genderColor(gender), weight: 3, opacity: 0.85 };
        },
        onEachFeature: (feat, layer) => {
          const tags = feat.properties && (feat.properties.tags || feat.properties);
          const name = tags && tags.name ? tags.name : "Senza nome";
          const qids = getQidsFromTags(tags);
          const qidList = qids.map(q => `<a href="https://www.wikidata.org/wiki/${q}" target="_blank" rel="noopener noreferrer">${q}</a>`).join(", ");
          layer.bindPopup(`<strong>${name}</strong><br>QID: ${qidList || "n/d"}`);
        }
      }).addTo(map);
    }

    async function runSearch() {
      const btn = document.getElementById("runBtn");
      const resultsDiv = document.getElementById("results");
      const summary = document.getElementById("summary");
      resultsDiv.innerHTML = "";
      summary.textContent = "";

      if (!selectionGeoJSON) {
        setStatus("Disegna un rettangolo o un poligono prima di eseguire.");
        return;
      }

      const query = buildOverpassQuery();
      document.getElementById("overpassQuery").value = query;

      btn.disabled = true;
      setStatus("Esecuzione Overpass in corso...");

      try {
        const osmData = await fetchOverpass(query);
        const elementsCount = (osmData.elements || []).length;
        setStatus(`Overpass OK (${elementsCount} elementi). Converto in GeoJSON...`);

        // Calcola vie distinte senza Wikidata
        const allElements = osmData.elements || [];
        const allStreetNames = new Set();
        allElements.forEach(el => {
          if (el.tags && el.tags.name && el.tags.highway) {
            allStreetNames.add(el.tags.name);
          }
        });

        const features = extractFeatures(osmData);
        if (!features.length) {
          resultsDiv.innerHTML = '<div class="muted">Nessuna via con etimologia Wikidata nell\'area selezionata.</div>';
          renderSummary([], 0, elementsCount, 0, allStreetNames.size);
          setStatus("Finito.");
          btn.disabled = false;
          return;
        }

        const qidSet = new Set();
        features.forEach(f => {
          const tags = f.properties && (f.properties.tags || f.properties);
          getQidsFromTags(tags).forEach(q => qidSet.add(q));
        });

        setStatus(`Trovati ${qidSet.size} QID. Query a Wikidata...`);
        const qidInfo = await fetchWikidataBatch(Array.from(qidSet));

        const rows = [];
        features.forEach(f => {
          const tags = f.properties && (f.properties.tags || f.properties);
          const name = tags.name || f.id;
          const qids = getQidsFromTags(tags);
          qids.forEach(qid => {
            const info = qidInfo.get(qid);
            if (!info) return; // salta QID non umano o non trovato
            const genderCategory = categorizeGender(info.genderId);
            rows.push({
              streetName: name,
              qid,
              personLabel: info.label || qid,
              dates: formatDateRange(info.birth, info.death),
              wikidataUrl: `https://www.wikidata.org/wiki/${qid}`,
              genderCategory
            });
          });
        });

        const deduped = dedupeRows(rows);

        // Calcola vie distinte con Wikidata
        const streetsWithWikidata = new Set();
        features.forEach(f => {
          const tags = f.properties && (f.properties.tags || f.properties);
          if (tags && tags.name) {
            streetsWithWikidata.add(tags.name);
          }
        });

        // Calcola vie distinte senza Wikidata
        const streetsWithoutWikidata = allStreetNames.size - streetsWithWikidata.size;

        renderSummary(deduped, qidSet.size, elementsCount, streetsWithWikidata.size, streetsWithoutWikidata);
        renderResults(deduped);
        renderMap(features, qidInfo);
        setStatus("Finito.");
      } catch (err) {
        console.error(err);
        resultsDiv.innerHTML = '<div class="muted">Errore: ' + err.message + "</div>";
        summary.textContent = "";
        setStatus("Errore: " + err.message);
      } finally {
        btn.disabled = false;
      }
    }
  </script>
</body>
</html>
